/*
 中国剩余定理（孙子定理）
三数为a b c，余数分别为 m1 m2 m3，%为求余计算，&&是“且”运算
⒈分别找出能被两个数整除，而满足被第三个整除余一的最小的数。
k1%b==k1%c==0 && k1%a==1;
k2%a==k2%c==0 && k2%b==1;
k3%a==k3%b==0 && k3%c==1;
⒉将三个数（能被两个数整除、除以第三个数余1）乘对应数字的余数再加起来，减去这三个数的最小公倍数即得结果。
Answer = k1×m1 + k2×m2 + k3×m3 - P×（a×b×c);
P为满足Answer > 0的最大整数；
或者 Answer = (k1×m1 + k2×m2 + k3×m3）%(a×b×c) ;
举例应用：
	一个数除以5余4，除以8余3，除以11余2，求满足条件的最小的自然数。
	题中5、8、11三个数两两互质。则〔8，11〕=88；〔5，11〕=55；〔5，8〕=40；
	〔5，8，11〕=440。为了使88被5除余1，用88×2=176；
	使55被8除余1，用55×7=385；使40被11除余1，用40×8=320。
	然后，176×4+385×3+320×2=2499，
	因为，2499>440，所以，2499－440×5=299，就是所求的数
*/ 

#include<stdio.h>
int a[10],b[10];
int main()
{
    int n,i,j;
    __int64 lcm,temp,ans;
    while(scanf("%d",&n)!=EOF) 
    {
        lcm=1;//lcm储存所有数的乘积 
        for(i=0; i<n; i++)
        {
            scanf("%d%d",&a[i],&b[i]);
            lcm*=a[i];
        }
        ans=0;
        for(i=0; i<n; i++)
        {
            temp=lcm/a[i];//去掉本身，剩下的为其他数的乘积 
            if(temp%a[i]!=0)//剪枝 
                for(j=1; (temp*j)%a[i]!=1; j++);//使：其他数的倍数%本身==1
            ans+=temp*b[i]*j;//满足的数*本身的余数 
        }
        printf("%I64d\n",ans%lcm);//所有组合的满足的数*本身的余数%所有数的乘积 即为结果
    }
    return 0;
}
